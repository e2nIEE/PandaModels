var documenterSearchIndex = {"docs":
[{"location":"develop/#Developer-Documentation","page":"Develop Mode","title":"Developer Documentation","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"warning: sync develop mode in pandapower\nEither you are developing a new feature or using the function from develop mode you should set the  option  pdm_dev_mode=True, e.g. :pp.runpm_vd(net, calculate_voltage_angles=True,\n        trafo_model=\"t\", delta=1e-8, trafo3w_losses=\"hv\", check_connectivity=True,\n        n_timesteps=96, time_elapsed=0.25, correct_pm_network_data=True,\n        pm_model=\"ACPPowerModel\", pm_time_limits=None, pm_log_level=0,\n        delete_buffer_file=False, pm_file_path=None,\n        pm_tol=1e-8, pdm_dev_mode=True)this option automatically check the setting and activate the develop mode environment.","category":"page"},{"location":"develop/#Develop-Mode","page":"Develop Mode","title":"Develop Mode","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"To install and develop PandaModels you can use either Git Bash or Python:","category":"page"},{"location":"develop/#Git-Bash:","page":"Develop Mode","title":"Git Bash:","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"To install and develop, PandaModels from Git Bash:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Open Julia REPL in Git Bash:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"$ julia","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"In Julia REPL, add the package:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"import Pkg\n# add package\nPkg.add(\"PandaModels\")\n# develop-mode\nPkg.develop(\"PandaModels\")\nPkg.build(\"PandaModels\")\nPkg.resolve()","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Check if your package is in develop mode:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"import PandaModels\npathof(PandaModels)","category":"page"},{"location":"develop/#Python:","page":"Develop Mode","title":"Python:","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"To install and develop, PandaModels directly from python:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"before running the following codes please set the Julia/python interface by following the steps in here.","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Call Julia in python:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"# call julia\nimport julia\nfrom julia import Main\nfrom julia import Pkg\n# add package\nPkg.add(\"PandaModels\")\n# develop-mode\nPkg.develop(\"PandaModels\")\nPkg.build(\"PandaModels\")\nPkg.resolve()","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Check if your package is in develop mode:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"from julia import Base\nBase.find_package(\"PandaModels\")","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"warning: Julia Version\nPyJulia crashes on Julia new released version 1.6.0, please install the older versions.","category":"page"},{"location":"develop/#Dependencies","page":"Develop Mode","title":"Dependencies","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"In develop-mode you need to add the following dependencies:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"optimization environment:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"JuMP.jl","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"infrastructure-based packages:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"InfrastructureModels.jl\nPowerModels.jl","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"logger:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Memento.jl","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"i/o:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"JSON.jl","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"solvers:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Ipopt.jl\nJuniper.jl\nCbc.jl","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Open Julia REPL in Git Bash:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"$ julia","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"In Julia REPL, add dependencies:","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"import Pkg\nPkg.Registry.update()\nPkg.add([\n    Pkg.PackageSpec(;name=\"JuMP\"),\n    Pkg.PackageSpec(;name=\"InfrastructureModels\"),\n    Pkg.PackageSpec(;name=\"PowerModels\"),\n    Pkg.PackageSpec(;name=\"PowerModelsDistribution\"),\n    Pkg.PackageSpec(;name=\"Memento\"),\n    Pkg.PackageSpec(;name=\"JSON\"),\n    Pkg.PackageSpec(;name=\"Ipopt\"),\n    Pkg.PackageSpec(;name=\"Juniper\"),\n    Pkg.PackageSpec(;name=\"Cbc\"),\n    ])\nPkg.build()\nPkg.resolve()","category":"page"},{"location":"develop/#Gurobi-Installation:","page":"Develop Mode","title":"Gurobi Installation:","text":"","category":"section"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"To use Gurobi, download and install from Gurobi Download Center, then get the license, activate it and add its path to the local PATH environment variables by following the steps from Gurobi License Center.","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"note: Linux Users\nfor linux users: open .bashrc file with , e.g., nano .bashrc in your home folder and add:export GUROBI_HOME=\"/opt/gurobi_VERSION/linux64\"\nexport PATH=\"${PATH}:${GUROBI_HOME}/bin\"\nexport LD_LIBRARY_PATH=\"${LD_LIBRARY_PATH}:${GUROBI_HOME}/lib\"\nexport GRB_LICENSE_FILE=\"/PATH_TO_YOUR_LICENSE_DIR/gurobi.lic\"","category":"page"},{"location":"develop/","page":"Develop Mode","title":"Develop Mode","text":"Finally, add the package to Julia by following installation instructions from Gurobi.jl.","category":"page"},{"location":"pf/#Run-Power-Flow","page":"Run Power Flow","title":"Run Power Flow","text":"","category":"section"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"pandapower now has an interface to PowerModels.jl that can be used for efficient power system optimization.","category":"page"},{"location":"pf/#What-is-PowerModels.jl-and-why-should-I-use-it?","page":"Run Power Flow","title":"What is PowerModels.jl and why should I use it?","text":"","category":"section"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"PowerModels.jl is  a package for steady-state power network optimization\nIt is based on the relatively new language Julia which is gaining popularity in scientific applications\nPowerModels uses Julia/JuMP for the optimization, which clearly outperforms the Python alternative Pyomo\nPowerModels has a great modular design that allows you to define different formulations for optimization problems based on different network formulations as well as use several relaxation schemes. You can then solve the problem using many open source as well as commercial solvers through JuMP","category":"page"},{"location":"pf/#Well-then-why-do-I-still-need-pandapower?","page":"Run Power Flow","title":"Well then why do I still need pandapower?","text":"","category":"section"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"Because pandapower:","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"allows you to easily define power systems with nameplate parameters and standard types\ncomes with thoroughly validated element models of transformers with tap changers, three-winding transformers, switches/breakers, extended ward equivalents and many more    \nkeeps all data in tables (pandas DataFrames), which makes data management and analysis very comfortable\nprovides different power system analysis functions, such as a (very fast) power flow, short-circuit calculation, state estimation, graph searches and a plotting library that can be used on the same grid models\nallows you to do all pre- and postprocessing in Python, which still has a much richer environment of free libraries than Julia (currently 157,755 packages on PyPI vs. 1,906 libraries on Pkg)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"So using pandapower to define the grid models and then using PowerModels for the optimization really gives you the best of all worlds - you can use the rich environment of Python libraries, the sophisticated element models of pandapower, the modular optimization framework of PowerModels and the efficient mathematical modeling of JuMP.","category":"page"},{"location":"pf/#Let's-get-started","page":"Run Power Flow","title":"Let's get started","text":"","category":"section"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"So here is an example of how it works. First, we create a grid in pandapower. Here, we create a meshed 110kV grid with four buses that is fed from an 220kV network through a 3-Winding transformer.","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"import pandapower as pp\nimport numpy as np\nnet = pp.create_empty_network()\n\nmin_vm_pu = 0.95\nmax_vm_pu = 1.05\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=220., geodata=(5,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus2 = pp.create_bus(net, vn_kv=110., geodata=(6,10), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus3 = pp.create_bus(net, vn_kv=110., geodata=(10,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus4 = pp.create_bus(net, vn_kv=110., geodata=(8,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus5 = pp.create_bus(net, vn_kv=110., geodata=(6,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\n\n#create 220/110/110 kV 3W-transformer\npp.create_transformer3w_from_parameters(net, bus1, bus2, bus5, vn_hv_kv=220, vn_mv_kv=110,\n                                        vn_lv_kv=110, vk_hv_percent=10., vk_mv_percent=10.,\n                                        vk_lv_percent=10., vkr_hv_percent=0.5,\n                                        vkr_mv_percent=0.5, vkr_lv_percent=0.5, pfe_kw=10,\n                                        i0_percent=0.1, shift_mv_degree=0, shift_lv_degree=0,\n                                        sn_hv_mva=100, sn_mv_mva=50, sn_lv_mva=50)\n\n#create 110 kV lines\nl1 = pp.create_line(net, bus2, bus3, length_km=70., std_type='149-AL1/24-ST1A 110.0')\nl2 = pp.create_line(net, bus3, bus4, length_km=50., std_type='149-AL1/24-ST1A 110.0')\nl3 = pp.create_line(net, bus4, bus2, length_km=40., std_type='149-AL1/24-ST1A 110.0')\nl4 = pp.create_line(net, bus4, bus5, length_km=30., std_type='149-AL1/24-ST1A 110.0')\n\n#create loads\npp.create_load(net, bus2, p_mw=60)\npp.create_load(net, bus3, p_mw=70)\npp.create_load(net, bus4, p_mw=10)\n\n#create generators\ng1 = pp.create_gen(net, bus1, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01, slack=True)\npp.create_poly_cost(net, g1, 'gen', cp1_eur_per_mw=1)\n\ng2 = pp.create_gen(net, bus3, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g2, 'gen', cp1_eur_per_mw=3)\n\ng3 = pp.create_gen(net, bus4, p_mw=50, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g3, 'gen', cp1_eur_per_mw=3)\nnet","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"This pandapower network includes the following parameter tables:\n   - bus (5 elements)\n   - load (3 elements)\n   - gen (3 elements)\n   - line (4 elements)\n   - trafo3w (1 element)\n   - poly_cost (3 elements)\n   - bus_geodata (5 elements)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"Note that PowerModels does not have a 3W-transformer model, but since pandapower includes the equations to calculates the equivalent branches for the 3W-transformers, it is possible to optimize grids with 3W-transformers in PowerModels through the pandapower interface. The same is true for other complex transformer models, switches/breaker, extended ward equivalents etc.","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"Let's have a look at the grid we created with pandapowers plotting module:","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"import pandapower.plotting as plot\n%matplotlib inline\nplot.simple_plot(net)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"(Image: png)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"<matplotlib.axes._subplots.AxesSubplot at 0x2c415203fd0>","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"Now lets run an PF through PowerModels and look at the results (Note that the first time the runpm function is called, Julia is started in the background, which may take some time):","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"<!–- complete this part after add pf functions to pandapower","category":"page"},{"location":"pf/#Timings","page":"Run Power Flow","title":"Timings","text":"","category":"section"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"Comparing the runpp function (that runs an PF through PYPOWER) and the runpm function shows that PowerModels is much more performant:","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"%timeit pp.runpp(net)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"1.22 s ± 14.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"%timeit pp.runpm_ac_pf(net)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"221 ms ± 7.18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"pf/","page":"Run Power Flow","title":"Run Power Flow","text":"–->","category":"page"},{"location":"pptutorial/#Run-Optimiyation-Problems-from-pandapower","page":"Optimazion Problems","title":"Run Optimiyation Problems from pandapower","text":"","category":"section"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"Now, by using PandaModels, pandapower has an interface to PowerModels.jl, also pandapower's users has access to some extra optimization models, e.g. voltage deviation minimization model, callable directly in pandapower.","category":"page"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"The tutorial for application of each optimization models are available in pandapower repository:","category":"page"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"Problems from PowerModels: <!– * Power Flow –>","category":"page"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"Power Flow\nOptimal Power Flow\nOptimal Transmission Switching\nTransmission Network Expansion Planning","category":"page"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"Problems from PandaModels:","category":"page"},{"location":"pptutorial/","page":"Optimazion Problems","title":"Optimazion Problems","text":"Voltage Deviation","category":"page"},{"location":"opf/#Run-Optimal-Power-Flow","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"","category":"section"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"pandapower now has an interface to PowerModels.jl that can be used for efficient power system optimization.","category":"page"},{"location":"opf/#What-is-PowerModels.jl-and-why-should-I-use-it?","page":"Run Optimal Power Flow","title":"What is PowerModels.jl and why should I use it?","text":"","category":"section"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"PowerModels.jl is  a package for steady-state power network optimization\nIt is based on the relatively new language Julia which is gaining popularity in scientific applications\nPowerModels.jl uses Julia/JuMP for the optimization, which clearly outperforms the Python alternative Pyomo\nPowerModels has a great modular design that allows you to define different formulations for optimization problems based on different network formulations as well as use several relaxation schemes. You can then solve the problem using many open source as well as commercial solvers through JuMP","category":"page"},{"location":"opf/#Well-then-why-do-I-still-need-pandapower?","page":"Run Optimal Power Flow","title":"Well then why do I still need pandapower?","text":"","category":"section"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Because pandapower:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"allows you to easily define power systems with nameplate parameters and standard types\ncomes with thoroughly validated element models of transformers with tap changers, three-winding transformers, switches/breakers, extended ward equivalents and many more    \nkeeps all data in tables (pandas DataFrames), which makes data management and analysis very comfortable\nprovides different power system analysis functions, such as a (very fast) power flow, short-circuit calculation, state estimation, graph searches and a plotting library that can be used on the same grid models\nallows you to do all pre- and postprocessing in Python, which still has a much richer environment of free libraries than Julia (currently 157,755 packages on PyPI vs. 1,906 libraries on Pkg)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"So using pandapower to define the grid models and then using PowerModels.jl for the optimization really gives you the best of all worlds - you can use the rich environment of Python libraries, the sophisticated element models of pandapower, the modular optimization framework of PowerModels.jl and the efficient mathematical modeling of JuMP.","category":"page"},{"location":"opf/#Let's-get-started","page":"Run Optimal Power Flow","title":"Let's get started","text":"","category":"section"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"So here is an example of how it works. First, we create a grid in pandapower. Here, we create a meshed 110kV grid with four buses that is fed from an 220kV network through a 3-Winding transformer.","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"import pandapower as pp\nimport numpy as np\nnet = pp.create_empty_network()\n\nmin_vm_pu = 0.95\nmax_vm_pu = 1.05\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=220., geodata=(5,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus2 = pp.create_bus(net, vn_kv=110., geodata=(6,10), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus3 = pp.create_bus(net, vn_kv=110., geodata=(10,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus4 = pp.create_bus(net, vn_kv=110., geodata=(8,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus5 = pp.create_bus(net, vn_kv=110., geodata=(6,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\n\n#create 220/110/110 kV 3W-transformer\npp.create_transformer3w_from_parameters(net, bus1, bus2, bus5, vn_hv_kv=220, vn_mv_kv=110,\n                                        vn_lv_kv=110, vk_hv_percent=10., vk_mv_percent=10.,\n                                        vk_lv_percent=10., vkr_hv_percent=0.5,\n                                        vkr_mv_percent=0.5, vkr_lv_percent=0.5, pfe_kw=10,\n                                        i0_percent=0.1, shift_mv_degree=0, shift_lv_degree=0,\n                                        sn_hv_mva=100, sn_mv_mva=50, sn_lv_mva=50)\n\n#create 110 kV lines\nl1 = pp.create_line(net, bus2, bus3, length_km=70., std_type='149-AL1/24-ST1A 110.0')\nl2 = pp.create_line(net, bus3, bus4, length_km=50., std_type='149-AL1/24-ST1A 110.0')\nl3 = pp.create_line(net, bus4, bus2, length_km=40., std_type='149-AL1/24-ST1A 110.0')\nl4 = pp.create_line(net, bus4, bus5, length_km=30., std_type='149-AL1/24-ST1A 110.0')\n\n#create loads\npp.create_load(net, bus2, p_mw=60)\npp.create_load(net, bus3, p_mw=70)\npp.create_load(net, bus4, p_mw=10)\n\n#create generators\ng1 = pp.create_gen(net, bus1, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01, slack=True)\npp.create_poly_cost(net, g1, 'gen', cp1_eur_per_mw=1)\n\ng2 = pp.create_gen(net, bus3, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g2, 'gen', cp1_eur_per_mw=3)\n\ng3 = pp.create_gen(net, bus4, p_mw=50, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g3, 'gen', cp1_eur_per_mw=3)\nnet","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"This pandapower network includes the following parameter tables:        - bus (5 elements)        - load (3 elements)        - gen (3 elements)        - line (4 elements)        - trafo3w (1 element)        - polycost (3 elements)        - busgeodata (5 elements)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Note that PowerModels does not have a 3W-transformer model, but since pandapower includes the equations to calculates the equivalent branches for the 3W-transformers, it is possible to optimize grids with 3W-transformers in PowerModels through the pandapower interface. The same is true for other complex transformer models, switches/breaker, extended ward equivalents etc.","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Let's have a look at the grid we created with pandapowers plotting module:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"import pandapower.plotting as plot\n%matplotlib inline\nplot.simple_plot(net)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"(Image: png)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Now lets run an OPF through PowerModels and look at the results (Note that the first time the runpm function is called, Julia is started in the background, which may take some time):","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"pp.runpm_ac_opf(net)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Since Generator 1 has the lowest cost, all required power is supplied through this generator:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.res_gen","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"gen p_mw q_mvar va_degree vm_pu\n0 1.448510e+02 11.037217 -1.390779e-28 1.050000\n1 -1.000000e-08 6.055925 -1.680643e+01 1.013179\n2 -1.000000e-08 13.126070 -1.298596e+01 1.040498","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"This however leeds to an overload in the three-winding transformer, through which g1 is connected:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.res_trafo3w.loading_percent","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"0    190.835372\nName: loading_percent, dtype: float64","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Let's set some constraints for the 3W-transformer and the lines and rerun the OPF:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.trafo3w[\"max_loading_percent\"] = 50\nnet.line[\"max_loading_percent\"] = 20\npp.runpm_ac_opf(net)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"The constraints are complied with for all lines and the 3W transformer:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.res_trafo3w.loading_percent","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"0    49.974771\nName: loading_percent, dtype: float64","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.res_line.loading_percent","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"0    19.047619\n1    12.295419\n2    19.207577\n3     7.088596\nName: loading_percent, dtype: float64","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"The power is now generated by a mixture of the generators:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"net.res_gen","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"gen p_mw q_mvar va_degree vm_pu\n0 24.531626 -6.267019 1.836953e-27 1.031058\n1 98.101643 -7.928710 -3.576364e-01 1.050000\n2 18.054898 9.928333 -1.446870e+00 1.048757","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"In order to use different models, please check Getting Started.","category":"page"},{"location":"opf/#Timings","page":"Run Optimal Power Flow","title":"Timings","text":"","category":"section"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"Comparing the runopp function (that runs an OPF through PYPOWER) and the runpm function shows that PowerModels is much more performant:","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"%timeit pp.runopp(net)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"1.22 s ± 14.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"%timeit pp.runpm_ac_opf(net)","category":"page"},{"location":"opf/","page":"Run Optimal Power Flow","title":"Run Optimal Power Flow","text":"221 ms ± 7.18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)","category":"page"},{"location":"quickguide/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"In python, for any net in pandapower or SimBench format, simply by calling pandapower.runpm function you are able to solve wide range of available OPF models, approximations and relaxations, from PowerModels.jl.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"runpm(net, julia_file=None, pp_to_pm_callback=None, calculate_voltage_angles=True,\n          trafo_model=\"t\", delta=1e-8, trafo3w_losses=\"hv\", check_connectivity=True,\n          correct_pm_network_data=True, pm_model=\"ACPPowerModel\", pm_solver=\"ipopt\",\n          pm_mip_solver=\"cbc\", pm_nl_solver=\"ipopt\", pm_time_limits=None, pm_log_level=0,\n          delete_buffer_file=True, pm_file_path = None, opf_flow_lim=\"S\", pm_tol=1e-8,\n          pdm_dev_mode=False, **kwargs)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"For example to run semi-definite relaxation of AC-OPF with :","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"import pandapower as pp\nimport pandapower.networks as nw\n\nnet = nw.example_simple()\npp.runpm(net, pm_model=\"SDPWRMPowerModel\", pm_solver=\"ipopt\", pm_nl_solver=\"juniper\")","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"exact non-convex model linear approximations quadratic approximations quadratic relaxations sdp relaxations\nACPPowerModel DCPPowerModel DCPLLPowerModel SOCWRPowerModel SDPWRMPowerModel\nACRPowerModel DCMPPowerModel LPACCPowerModel SOCWRConicPowerModel SparseSDPWRMPowerModel\nACTPowerModel BFAPowerModel  SOCBFPowerModel \nIVRPowerModel NFAPowerModel  SOCBFConicPowerModel \n   QCRMPowerModel \n   QCLSPowerModel ","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Different solver options are available in PandaModels. For more information please check the supported solvers by JuMP.jl in here.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solvers support license\nJuniper (MI)SOCP, (MI)NLP MIT\nIpopt LP, QP, NLP EPL\nCbc (MI)LP EPL\nGurobi (MI)LP, (MI)SOCP Comm.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"For DC and AC OPF, you can directly call pandapower.runpm_dc_opf and pandapower.runpm_ac_opf, respectively.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"For example:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"import pandapower as pp\nimport pandapower.networks as nw\n\nnet = nw.example_simple()\npp.runpm_ac_opf(net)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"for more  details about the settings please see here, also the detailed tutorial is available in Tutorials.","category":"page"},{"location":"tnep/#Run-Transmission-Network-Expansion-Planning","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"This tutorial describes how to run the TNEP feature of PowerModels.jl together with pandapower.","category":"page"},{"location":"tnep/#Choose-Proper-Solver","page":"Run Transmission Network Expansion Planning","title":"Choose Proper Solver","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"The TNEP problem is a mixed-integer non-linear problem, which is especially not easy to solve. To be able to solve these kind of problems, you need a suitable solver. Either you use commercial ones (such as Knitro) or the open-source Juniper solver which is partly developed by Carleton Coffrin from PowerModels itself. Additionally CBC is needed.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Note that Juniper is a heuristic based solver. Another non-heuristic option would be to use Alpine","category":"page"},{"location":"tnep/#Prepare-the-Input-Data","page":"Run Transmission Network Expansion Planning","title":"Prepare the Input Data","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"To put it simple, the goal of the optimization is to find a set of new lines from a pre-defined set of possible new lines so that not voltage or line loading violations are violated.   ","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"In order to start the optimization, we have to define certain things:","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"The \"common\" pandapower, or SimBench, grid data with line loading and voltage limits\nThe set of available new lines to choose from","category":"page"},{"location":"tnep/#Create-the-grid","page":"Run Transmission Network Expansion Planning","title":"Create the grid","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"In this example we use the CIGRE medium voltage grid from pandapower.networks and define the limits for all lines / buses as:","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"max line loading limit: 60%\nmin voltage magnitude: 0.95 p.u.\nmax voltage magnitude: 1.05 p.u.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"import pandapower.networks as nw\nfrom pandapower.converter.powermodels.to_pm import init_ne_line\n\ndef cigre_grid():\n    net = nw.create_cigre_network_mv()\n\n    net[\"bus\"].loc[:, \"min_vm_pu\"] = 0.95\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = 1.05\n\n    net[\"line\"].loc[:, \"max_loading_percent\"] = 60.\n    return net\n","category":"page"},{"location":"tnep/#Define-the-new-line-measures-to-choose-from","page":"Run Transmission Network Expansion Planning","title":"Define the new line measures to choose from","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Since we want to solve a line loading problem, we define \"parallel\" lines to all existing lines to choose from. To define this, two steps are necessary:","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Create new lines in the existing \"line\" DataFrame and set them out of service\nCreate the \"ne_line\" DataFrame which specifies which lines are the possible ones to be built. This DataFrame is","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"similar to the line DataFrame, except that is has an additional column \"construction_cost\". These define the costs for the lines to be built.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Note that it is important to set the lines \"out of service\" in the line DataFrame. Otherwise, they are already \"built\". In the \"neline\" DataFrame the lines are set \"in service\". The initne_line() function takes care of this.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"import pandas as pd\nimport numpy as np\n\ndef define_possible_new_lines(net):\n    # Here the possible new lines are a copy of all the lines which are already in the grid\n    max_idx = max(net[\"line\"].index)\n    net[\"line\"] = pd.concat([net[\"line\"]] * 2, ignore_index=True) # duplicate\n    # they must be set out of service in the line DataFrame (otherwise they are already \"built\")\n    net[\"line\"].loc[max_idx + 1:, \"in_service\"] = False\n    # get the index of the new lines\n    new_lines = net[\"line\"].loc[max_idx + 1:].index\n\n    # creates the new line DataFrame net[\"ne_line\"] which defines the measures to choose from. The costs are defined\n    # exemplary as 1. for every line.\n    init_ne_line(net, new_lines, construction_costs=np.ones(len(new_lines)))\n\n    return net\n","category":"page"},{"location":"tnep/#Run-the-optimization","page":"Run Transmission Network Expansion Planning","title":"Run the optimization","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Now we run the optimization and print the results. First we initiate the grid with the new lines and check if some limits are violated (otherwise there is not much to optimize). Then we run runpm_tnep(net) and print the newly built lines and assert the line loading limits with a power flow calculation.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"The newly built lines can be found in the DataFrame net[\"resneline\"], which has one column \"built\". A newly built line is marked as True, otherwise False.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"import pandapower as pp\n\ndef pm_tnep_cigre():\n    # get the grid\n    net = cigre_grid()\n    # add the possible new lines\n    define_possible_new_lines(net)\n    # check if max line loading percent is violated (should be)\n    pp.runpp(net)\n    print(\"Max line loading prior to optimization:\")\n    print(net.res_line.loading_percent.max())\n    assert np.any(net[\"res_line\"].loc[:, \"loading_percent\"] > net[\"line\"].loc[:, \"max_loading_percent\"])\n\n    # run power models tnep optimization\n    pp.runpm_tnep(net)\n    # print the information about the newly built lines\n    print(\"These lines are to be built:\")\n    print(net[\"res_ne_line\"])\n\n    # set lines to be built in service\n    lines_to_built = net[\"res_ne_line\"].loc[net[\"res_ne_line\"].loc[:, \"built\"], \"built\"].index\n    net[\"line\"].loc[lines_to_built, \"in_service\"] = True\n\n    # run a power flow calculation again and check if max_loading percent is still violated\n    pp.runpp(net)\n\n    # check max line loading results\n    assert not np.any(net[\"res_line\"].loc[:, \"loading_percent\"] > net[\"line\"].loc[:, \"max_loading_percent\"])\n\n    print(\"Max line loading after the optimization:\")\n    print(net.res_line.loading_percent.max())\n","category":"page"},{"location":"tnep/#Notes","page":"Run Transmission Network Expansion Planning","title":"Notes","text":"","category":"section"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Juniper is based on a heuristic, it does not necessarly find the global optimum. For this use another solver\nIn the PowerModels OPF formulation, generator limits are taken into account. This means you have to specify limits for all gens, ext_grids and controllable sgens / loads.\nOptionally costs for these can be defined.\nThe CIGRE MV grid has pre-defined limits set for the ext_grid. In other cases you might get an error.","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"Here is a code snippet:","category":"page"},{"location":"tnep/","page":"Run Transmission Network Expansion Planning","title":"Run Transmission Network Expansion Planning","text":"def define_ext_grid_limits(net):\n    # define limits\n    net[\"ext_grid\"].loc[:, \"min_p_mw\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_p_mw\"] = 9999.\n    net[\"ext_grid\"].loc[:, \"min_q_mvar\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_q_mvar\"] = 9999.\n    # define costs\n    for i in net.ext_grid.index:\n        pp.create_poly_cost(net, i, 'ext_grid', cp1_eur_per_mw=1)","category":"page"},{"location":"test/#Test-Guidelines","page":"Add Test","title":"Test Guidelines","text":"","category":"section"},{"location":"test/#Test-PandaModels","page":"Add Test","title":"Test PandaModels","text":"","category":"section"},{"location":"test/","page":"Add Test","title":"Add Test","text":"Add the .json file of the pandapower net in data in test directory. update the runtests.jl file, and add tests, at least, for the .json file, user defined parameters and termination status.","category":"page"},{"location":"test/#Test-pandapower","page":"Add Test","title":"Test pandapower","text":"","category":"section"},{"location":"test/","page":"Add Test","title":"Add Test","text":"All changes in PandaModels should be synced to pandapower. To test the changes, first checkout to develop branch in pandapower. Add the test for new function in pandapower, then in Python:","category":"page"},{"location":"test/","page":"Add Test","title":"Add Test","text":"import pandapower.test\npandapower.test.run_all_tests()","category":"page"},{"location":"test/","page":"Add Test","title":"Add Test","text":"please check here to find out how call the new model in pandapower.","category":"page"},{"location":"omns/#Run-Optimal-MultiNetwork-Storage","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"This tutorial describes how to run a storage optimization over multiple timesteps with a PowerModels.jl multinetwork together with pandapower.","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"To run a storage optimization over multiple time steps, the power system data is copied n_timestep times internally. This is done efficiently in a julia script. Each network in the multinetwork dict represents a single time step. The input time series must be written to the loads and generators accordingly to each network. This is currently done by converting input time series to a dict, saving it as a json file and loading the data back in julia. This \"hack\" is probably just a temporary solution.","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"Some notes:","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"only storages which are set as \"controllable\" are optimized\ntime series can be written to load / sgen elements only at the moment\noutput of the optimization is a dict containing pandas DataFrames for every optimized storage and time step   ","category":"page"},{"location":"omns/#Run-the-storage-optimization","page":"Run Optimal MultiNetwork Storage","title":"Run the storage optimization","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"In order to start the optimization and visualize results, we follow four steps:","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"Load the pandapower grid data (here the cigre MV grid)\nConvert the time series to the dict\nStart the optimization\nplot the results","category":"page"},{"location":"omns/#Get-the-grid-data","page":"Run Optimal MultiNetwork Storage","title":"Get the grid data","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"We load the cigre medium voltage grid with \"pv\" and \"wind\" generators. Also we set some limits and add a storage with controllable == True","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"import json\nimport os\nimport tempfile\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport pandapower as pp\nimport pandapower.networks as nw\n\ndef cigre_grid():\n    net = nw.create_cigre_network_mv(\"pv_wind\")\n    # set some limits\n    min_vm_pu = 0.95\n    max_vm_pu = 1.05\n\n    net[\"bus\"].loc[:, \"min_vm_pu\"] = min_vm_pu\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = max_vm_pu\n\n    net[\"line\"].loc[:, \"max_loading_percent\"] = 100.\n\n    # close all switches\n    net.switch.loc[:, \"closed\"] = True\n    # add storage to bus 10\n    pp.create_storage(net, 10, p_mw=0.5, max_e_mwh=.2, soc_percent=0., q_mvar=0., controllable=True)\n\n    return net\n\n","category":"page"},{"location":"omns/#Convert-the-time-series-to-a-dict","page":"Run Optimal MultiNetwork Storage","title":"Convert the time series to a dict","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"The following functions loads the example time series from the input_file and scales the power accordingly. It then stores the dict to a json file to a temporary folder.","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"def convert_timeseries_to_dict(net, input_file):\n    # set the load type in the cigre grid, since it is not specified\n    net[\"load\"].loc[:, \"type\"] = \"residential\"\n    # change the type of the last sgen to wind\n    net.sgen.loc[:, \"type\"] = \"pv\"\n    net.sgen.loc[8, \"type\"] = \"wind\"\n\n    # read the example time series\n    time_series = pd.read_json(input_file)\n    time_series.sort_index(inplace=True)\n    # this example time series has a 15min resolution with 96 time steps for one day\n    n_timesteps = time_series.shape[0]\n\n    n_load = len(net.load)\n    n_sgen = len(net.sgen)\n    p_timeseries = np.zeros((n_timesteps, n_load + n_sgen), dtype=float)\n    # p\n    load_p = net[\"load\"].loc[:, \"p_mw\"].values\n    sgen_p = net[\"sgen\"].loc[:7, \"p_mw\"].values\n    wind_p = net[\"sgen\"].loc[8, \"p_mw\"]\n\n    p_timeseries_dict = dict()\n    for t in range(n_timesteps):\n        # print(time_series.at[t, \"residential\"])\n        p_timeseries[t, :n_load] = load_p * time_series.at[t, \"residential\"]\n        p_timeseries[t, n_load:-1] = - sgen_p * time_series.at[t, \"pv\"]\n        p_timeseries[t, -1] = - wind_p * time_series.at[t, \"wind\"]\n        p_timeseries_dict[t] = p_timeseries[t, :].tolist()\n\n    time_series_file = os.path.join(tempfile.gettempdir(), \"timeseries.json\")\n    with open(time_series_file, 'w') as fp:\n        json.dump(p_timeseries_dict, fp)\n\n    return net, p_timeseries_dict\n","category":"page"},{"location":"omns/#Start-the-optimization","page":"Run Optimal MultiNetwork Storage","title":"Start the optimization","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"Here we start the optimization for the 15min resolution time series. Since we have 96 time steps and 15 min resolution we set ntimesteps=96 and timeelapsed=.25 as a quarter of an hour.","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"# open the cigre mv grid\nnet = cigre_grid()\n# convert the time series to a dict and save it to disk\ninput_file = \"assets/cigre_timeseries_15min.json\"\nnet, p_timeseries = convert_timeseries_to_dict(net, input_file)\n# run the PowerModels.jl optimization\n# n_time steps = 96 and time_elapsed is a quarter of an hour (since the time series are in 15min resolution)\nstorage_results = pp.runpm_storage_opf(net, n_timesteps=96, time_elapsed=0.25)\n","category":"page"},{"location":"omns/#Store-the-results-(optionally)","page":"Run Optimal MultiNetwork Storage","title":"Store the results (optionally)","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"Store the results to a json file","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"def store_results(storage_results, grid_name):\n    for key, val in storage_results.items():\n        file = grid_name + \"_strg_res\" + str(key) + \".json\"\n        print(\"Storing results to file {}\".format(file))\n        print(val)\n        val.to_json(file)\n# store the results to disk optionally\nstore_results(storage_results, \"cigre_ts\")\n","category":"page"},{"location":"omns/#Plot-the-results","page":"Run Optimal MultiNetwork Storage","title":"Plot the results","text":"","category":"section"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"Plot the optimization results for the storage.","category":"page"},{"location":"omns/","page":"Run Optimal MultiNetwork Storage","title":"Run Optimal MultiNetwork Storage","text":"def plot_storage_results(storage_results):\n    n_res = len(storage_results.keys())\n    fig, axes = plt.subplots(n_res, 2)\n    if n_res == 1:\n        axes = [axes]\n    for i, (key, val) in enumerate(storage_results.items()):\n        res = val\n        axes[i][0].set_title(\"Storage {}\".format(key))\n        el = res.loc[:, [\"p_mw\", \"q_mvar\", \"soc_mwh\"]]\n        el.plot(ax=axes[i][0])\n        axes[i][0].set_xlabel(\"time step\")\n        axes[i][0].legend(loc=4)\n        axes[i][0].grid()\n        ax2 = axes[i][1]\n        patch = plt.plot([], [], ms=8, ls=\"--\", mec=None, color=\"grey\", label=\"{:s}\".format(\"soc_percent\"))\n        ax2.legend(handles=patch)\n        ax2.set_label(\"SOC percent\")\n        res.loc[:, \"soc_percent\"].plot(ax=ax2, linestyle=\"--\", color=\"grey\")\n        ax2.grid()\n\n    plt.show()\n# plot the result\nplot_storage_results(storage_results)","category":"page"},{"location":"ots/#Run-Optimal-Transmission-Switching","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"This tutorial describes how to run the OTS feature of PowerModels.jl together with pandapower.","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"The OTS allows to optimize the \"switching state\" of a (meshed) grid by taking lines out of service. This not exactly the same as optimizing the switching state provided by pandapower. In the OTS case every in service branch element in the grid is taken into account in the optimization. This includes all lines and transformers. The optimization then chooses some lines/transformers to be taken out of service in order to minimize fuel cost, see available objectives options.","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"To summerize this means:","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"the switching state of the pandapower switches are not changed\nall lines / transformer in service states are variables of the optimization\noutput of the optimization is a changed \"inservice\" state in the resline / res_trafo... tables.   ","category":"page"},{"location":"ots/#Choose-Proper-Solver","page":"Run Optimal Transmission Switching","title":"Choose Proper Solver","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"The OTS problem is a mixed-integer non-linear problem, which is especially not easy to solve. To be able to solve these kind of problems, you need a suitable solver. Either you use commercial ones (such as Knitro) or the open-source Juniper solver which is partly developed by Carleton Coffrin from PowerModels itself. Additionally CBC is needed.","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"Note that Juniper is a heuristic based solver. Another non-heuristic option would be to use Alpine","category":"page"},{"location":"ots/#Prepare-the-Input-Data","page":"Run Optimal Transmission Switching","title":"Prepare the Input Data","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"To put it simple, the goal of the optimization is to find a changed in_service state for the branch elements (lines, transformers). Note that the OPF calculation also takes into account the voltage and line loading limits.   ","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"In order to start the optimization, we follow two steps:","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"Load the pandapower, or SimBench, grid data\nStart the optimization","category":"page"},{"location":"ots/#Run-OTS","page":"Run Optimal Transmission Switching","title":"Run OTS","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"In this example we use the tset case grid from pandapower.networks:","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"import pandapower.networks as nw\nimport pandapower as pp\n\n# here we use the simple case5 grid\nnet = nw.case5()\nline_status = net[\"line\"].loc[:, \"in_service\"].values\nprint(\"Line status prior to optimization is:\")\nprint(line_status.astype(bool))\n\n# runs the powermodels.jl switch optimization\npp.runpm_ots(net)\n# note that the result is taken from the res_line instead of the line table. The input DataFrame is not changed\nline_status = net[\"res_line\"].loc[:, \"in_service\"].values\nprint(\"Line status after the optimization is:\")\nprint(line_status.astype(bool))\n\n","category":"page"},{"location":"ots/#What-to-do-with-the-result","page":"Run Optimal Transmission Switching","title":"What to do with the result","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"The optimized line / trafo status can be found in the result DataFrames, e.g. net[\"res_line\"]. The result ist not automatically written to the inputs (\"line\" DataFrame). To do this you can use:","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"import pandapower as pp    \n\n# Change the input data\nnet[\"line\"].loc[:, \"in_service\"] = net[\"res_line\"].loc[:, \"in_service\"].values\nnet[\"trafo\"].loc[:, \"in_service\"] = net[\"res_trafo\"].loc[:, \"in_service\"].values\n\n# optional: run a power flow calculation with the changed in service status\npp.runpp(net)","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"If you have line-switches / trafo-switches at these lines/trafos you could also search for the switches connected to these elements (with the topology search) and change the switching state according to the in_service result. This should deliver identical results as changing the in service status of the element. However, this requires to have line switches at both ends of the line. If you just open the switch on one of the two sides, the power flow result is slightly different since the line loading of the line without any connected elements is calculated.","category":"page"},{"location":"ots/#Notes","page":"Run Optimal Transmission Switching","title":"Notes","text":"","category":"section"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"Juniper is based on a heuristic, it does not necessarly find the global optimum. For this use another solver\nIn the PowerModels OPF formulation, generator limits are taken into account. This means you have to specify limits for all gens, ext_grids and controllable sgens / loads.\nOptionally costs for these can be defined.\nAlso limits for line/trafo loadings and buse voltages are to be defined. The case5 grid has pre-defined limits set. In other cases you might get an error.","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"Here is a code snippet:","category":"page"},{"location":"ots/","page":"Run Optimal Transmission Switching","title":"Run Optimal Transmission Switching","text":"def define_ext_grid_limits(net):\n    # define line loading and bus voltage limits\n    min_vm_pu = 0.95\n    max_vm_pu = 1.05\n\n    net[\"bus\"].loc[:, \"min_vm_pu\"] = min_vm_pu\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = max_vm_pu\n\n    net[\"line\"].loc[:, \"max_loading_percent\"] = 100.\n    net[\"trafo\"].loc[:, \"max_loading_percent\"] = 100.\n\n    # define limits\n    net[\"ext_grid\"].loc[:, \"min_p_mw\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_p_mw\"] = 9999.\n    net[\"ext_grid\"].loc[:, \"min_q_mvar\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_q_mvar\"] = 9999.\n    # define costs\n    for i in net.ext_grid.index:\n        pp.create_poly_cost(net, i, 'ext_grid', cp1_eur_per_mw=1)","category":"page"},{"location":"#PandaModels.jl","page":"Home","title":"PandaModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PandaModels","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PandaModels.jl is a Julia package which containing supplementary data and codes to prepare pandapower networks in a compatible format for Julia packages which are based on InfrastructureModels, such as PowerModels.jl to run and calculate steady-state power network optimization. These packages use JuMP as optimization environment.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Install-Julia","page":"Home","title":"Install Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are not yet using Julia, install it. Note that you need a version that is supported PowerModels, PyCall and pyjulia for the interface to work. Currently, Julia 1.5  is the most recent stable version of Julia that supports all these packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You don't necessarily need a Julia IDE if you are using PowerModels through pandapower, but it might help for debugging to install an IDE such as Juno. Also, PyCharm has a Julia Plugin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add the Julia binary folder (e.g. /Julia-1.5.0/bin) to the system variable PATH Providing the path is correct, you can now enter the Julia prompt by executing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia","category":"page"},{"location":"#Install-PyCall","page":"Home","title":"Install PyCall","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia package PyCall allows to call Python in Julia. By default, PyCall uses the Conda.jl package to install a Miniconda distribution private to Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"PyCall\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use an already installed Python distribution (e.g. Anaconda), set the PYTHON environment variable inside the Julia prompt to e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ENV[\"PYTHON\"]=\"C:\\\\Anaconda3\\\\python.exe\"\nimport Pkg\nPkg.build(\"PyCall\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"test if calling Python from Julia works as described here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you cannot plot using PyCall and PyPlot in Julia, see the workarounds offered here.","category":"page"},{"location":"#Install-PyJulia","page":"Home","title":"Install PyJulia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At the moment only the pip package manager, not conda, is supported in Python to install the PyJulia package, the name of the PyJulia package in pip is Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pip install julia","category":"page"},{"location":"#Install-Package","page":"Home","title":"Install Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to use the PandaModels.jl package out of Python/pandapower environment, you can install is as a registered package by using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"PandaModels\")\nPkg.build(\"PandaModels\")\nPkg.resolve()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Otherwise, the package will be automatically installed in pandapower environment by applying the PyJulia-PyCall interface.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has been developed as part of the De­part­ment of En­er­gy Ma­nage­ment and Power Sys­tem Ope­ra­ti­on (e²n), University of Kassel and Fraunhofer Institute for Energy Economics and Energy System Technology (IEE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The developers thank Carleton Coffrin, the primary developer of PowerModels.jl, for his support.","category":"page"}]
}
